<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Model XML Validator</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
    }
    #log {
      margin-top: 1rem;
      white-space: pre-wrap;
      font-family: monospace;
      border: 1px solid #ccc;
      padding: 1rem;
    }
  </style>
</head>
<body>

  <input type="file" id="loadLanguage" accept=".xml">
  <label for="loadLanguage">Load language</label>

  <br><br>

  <input type="file" id="loadModel" accept=".xml">
  <label for="loadModel">Load model</label>


  <div id="log"></div>

  <script>
  let languageEnv = null;

  document
    .addEventListener("DOMContentLoaded", () => enableControls(false) );

  document
    .getElementById("loadLanguage")
    .addEventListener("change", onLoadLanguageChange);

  document
    .getElementById("loadModel")
    .addEventListener("change", onLoadModelChange);

  function enableControls(isLanguageLoaded){
    enableInput(document.getElementById("loadModel"),isLanguageLoaded);
  }
  
  function onLoadLanguageChange(e){
    const file = e.target.files[0];
    if (!file) return;
    setValidLanguage(file);
  };

  function onLoadModelChange(ev){
    if (!languageEnv) {
      rejectLoad(ev.target, "✖ Load language.xml first.\n");
      return;
    }
    const file = ev.target.files[0];
    if (!file) return;
    parseAndValidateLoadedModel(file, languageEnv);
  };

  function setValidLanguage(file){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const xml = new DOMParser().parseFromString(reader.result, "text/xml");
        const lang = parseAndValidateLanguage(xml, file.name);
        commitLanguage(lang);
      } catch (er) {
        rejectLanguage(er);
      }
    };
    reader.readAsText(file);
  }

  function commitLanguage(lang) {
    languageEnv = lang;
    logLoadingOfLanguage(lang);
    enableControls(true);
  }

  function rejectLanguage(er) {
    languageEnv = null;
    setLogText("✖ Validation error:\n" + er.message);
    enableControls(false);
  }

  function parseAndValidateLoadedModel(file, language){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const fileReadAsXML = new DOMParser().parseFromString(reader.result, "application/xml");
        const fileReadAsObj = getObjectFromXML(fileReadAsXML);
        const result = getModelFeatures(fileReadAsObj, language);
        setLogText("✔ Model is structurally valid\n\n" +
          "Index sets:\n" + result.indexSets.join(", ") + "\n\n" +
          "Variables:\n" + result.variables.join(", ") + "\n\n" + 
          "resolvedVars:\n"  + getObjectAsString(mapToObject(result.resolvedVars)) + "\n\n" + 
          "dependencies:\n"  + getObjectAsString(mapOfSetsToObject(result.dependencies)) + "\n\n" + 
          file.name + " as object:\n" + getObjectAsString(fileReadAsObj));
      } catch (er) {
        setLogText("✖ Validation error:\n" +
          er.message +
          "\n\nContext:\n" +
          getObjectAsString(er.context));
      }
    };
    reader.readAsText(file);
  };

  function parseAndValidateLanguage(xmlDoc, filename) {
    const functions = new Map();
    const fnNodes = xmlDoc.querySelectorAll("functions > function");
    for (const fn of fnNodes) {
      const name = fn.getAttribute("name");
      const arity = Number(fn.getAttribute("arity"));
      const serializer = new XMLSerializer();
      const fnXml = serializer.serializeToString(fn);
      if (!name ) {
        throw new Error("Invalid function declaration in " + filename + ": function without name \n" + fnXml);
      }
      if (Number.isNaN(arity)) {
        throw new Error("Invalid function declaration in " + filename + ": function with non-numeric arity \n" + fnXml);
      }
      functions.set(name, { arity });
    }
    return { functions };
  }

  function logLoadingOfLanguage(lang) {
      setLogText(formatLanguageLoaded(lang));
      console.log("Language loaded:", lang);
  }

  function formatLanguageLoaded(lang) {
    return "Language loaded:\n " + getObjectAsString(
      { functions: Object.fromEntries(lang.functions) }
    );
  }

  /* ===========================
     XML → JS object
     =========================== */
  function getObjectFromXML(xml) {
    function getObjectFromNode(node) {
      const obj = {};
      // attributes
      if (node.attributes) {
        for (const attr of node.attributes) {
          obj[attr.name] = attr.value;
        }
      }
      // child nodes
      for (const child of node.childNodes) {
        if (child.nodeType === Node.ELEMENT_NODE) { // === 1
          const name = child.nodeName;
          const value = getObjectFromNode(child);
          if (obj[name]) {  // obj[name] already exists so Make it an array and add elements to the array
            if (!Array.isArray(obj[name])) {
              obj[name] = [obj[name]];
            }
            obj[name].push(value);
          } else {  // obj[name] doesn't exist so create it and set its value
            obj[name] = value;
          }
        }
        if (child.nodeType === Node.TEXT_NODE ) { // === 3
          const text = child.nodeValue.trim();
          if (text) {
            obj["#text"] = text;  // so if there is more than one bit of text it just takes the last one
          }
        }
      }
      return obj;
    }
    return { model: getObjectFromNode(xml.documentElement) };
  }

  function getModelFeatures(xmlModel, lang) {
    const symbols = collectSymbols(xmlModel);
    const resolvedVars = resolveDomains(symbols);
    const dependencies = resolveReferences(symbols, resolvedVars, lang);
    detectCycles(dependencies);
    return {
      indexSets: [...symbols.indexSets.keys()],   // an array containing all the keys from the indexSets map
      variables: [...symbols.variables.keys()],    // an array containing all the keys from the variables map
      resolvedVars,
      dependencies   
    };
  }


  /* ===========================
     Validate Step 1: Collect symbols
     =========================== */
  function collectSymbols(xml) {
    const indexSets = new Map();
    const units = new Map();
    const tables = new Map();
    const variables = new Map();

    for (const is of asArray(xml.model.indexSets?.indexSet)) {
      if (indexSets.has(is.id)) {
        throwModelError("Duplicate index set", { id: is.id });
      }
      indexSets.set(is.id, is);
    }

    for (const u of asArray(xml.model.units?.unit)) {
      units.set(u.id, u);
    }

    for (const t of asArray(xml.model.tables?.table)) {
      tables.set(t.id, t);
    }

    for (const v of asArray(xml.model.variables?.variable)) {
      if (variables.has(v.id)) {
        throwModelError("Duplicate variable", { id: v.id });
      }
      variables.set(v.id, v);
    }

    return { indexSets, units, tables, variables };
  }

  /* ===========================
     Validate Step 2: Resolve domains
     =========================== */
  function resolveDomains(symbols) {
    const resolved = new Map();

    for (const [name, v] of symbols.variables) {
      const args = [];

      for (const arg of asArray(v.arguments?.arg)) {
        const indexSet = symbols.indexSets.get(arg.indexSet);
        if (!indexSet) {
          throwModelError("Unknown index set", {
            variable: name,
            indexSet: arg.indexSet
          });
        }
        args.push(indexSet.id);
      }

      resolved.set(name, {
        name,
        domain: args,
        xml: v
      });
    }

    return resolved;
  }

  /* ===========================
     Validate Step 3: Resolve references
     =========================== */
  function resolveReferences(symbols, resolvedVars, lang) {
    const dependencies = new Map();

    for (const [name, resolvedVariable] of resolvedVars) {
      dependencies.set(name, new Set());
      const def = resolvedVariable.xml.definition;
      if (!def) continue;

      if (def.type === "expression") {
        const refs = extractStringsFollowedByBrackets(def["#text"] || "");
        for (const r of refs) {
          if (symbols.variables.has(r)) {
            dependencies.get(name).add(r);
            continue;
          }

          if (lang.functions.has(r)) {
            continue; // built-in function
          }

          throwModelError("Unknown identifier", {
            variable: name,
            reference: r
          });
        }
      }

      if (def.type === "table") {
        const tableId = def.table?.ref;
        if (!symbols.tables.has(tableId)) {
          throwModelError("Unknown table", {
            variable: name,
            table: tableId
          });
        }
      }
    }

    return dependencies;
  }

  function extractStringsFollowedByBrackets(exprText) {
    const regex = /([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;   // all matches of strings followed by left round bracket 
    const refs = new Set();
    let m;
    while ((m = regex.exec(exprText)) !== null) {
      refs.add(m[1]);
    }
    return [...refs];
  }


  /* ===========================
     Validate Step 4: Cycle detection
     =========================== */
  function detectCycles(dependencies) {
    const visited = new Set();
    const stack = new Set();

    function visit(v) {
      if (stack.has(v)) return [v];
      if (visited.has(v)) return null;

      visited.add(v);
      stack.add(v);

      for (const d of dependencies.get(v) || []) {
        const cycle = visit(d);
        if (cycle) {
          cycle.push(v);
          return cycle;
        }
      }

      stack.delete(v);
      return null;
    }

    for (const v of dependencies.keys()) {
      const cycle = visit(v);
      if (cycle) {
        throwModelError("Dependency cycle detected", { cycle });
      }
    }
  }

  /* ===========================
     Helpers
     =========================== */
  function asArray(x){
    return [].concat(x || []);
  }
  
  function enableInput(el, qualifier){
    el.disabled = !qualifier;
  };

  function setLogText(s){
      const log = document.getElementById("log");
      log.textContent = s;
  }

  function throwModelError(message, context = {}) {
    const err = new Error(message);
    err.context = context;
    throw err;
  }

  function mapToObject(map) {
    return Object.fromEntries(map);
  }

  function mapOfSetsToObject(map) {
    return Object.fromEntries(
      [...map.entries()].map(([k, v]) => [k, [...v]])
    );
  }

  function getObjectAsString(obj) {
    return  JSON.stringify(obj || {}, null, 2);
  }

  function rejectLoad(input, message) {
    setLogText(message);
    input.value = null;
  }


  </script>

</body>
</html>
