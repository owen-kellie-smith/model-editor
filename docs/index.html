<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">  
  <title>Model XML Validator</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
    }
    #log {
      margin-top: 1rem;
      white-space: pre-wrap;
      font-family: monospace;
      border: 1px solid #ccc;
      padding: 1rem;
    }
    .editor-container {
      display: flex;
      gap: 24px;
      align-items: flex-start;
    }
    
    .editor {
      display: flex;
      flex-direction: column;
    }

    .editor textarea {
      flex: 1;              /* fills available space */
      min-height: 130px;    /* pick a height you like */
      resize: vertical;    /* optional: allow user resize */
    }

    /* ======================================================
       Mobile layout
       ====================================================== */
    @media (max-width: 768px) {

      body {
        padding: 1rem;
      }

      .editor-container {
        flex-direction: column;   /* stack */
        gap: 16px;
      }

      .editor textarea {
        width: 100%;              /* ignore cols="80" */
        min-height: 180px;
        font-size: 16px;          /* stops iOS zoom */
      }

      input[type="file"],
      button {
        font-size: 16px;          /* easier tapping */
      }

      #log {
        font-size: 14px;
        overflow-x: auto;
      }
    }

  </style>
</head>
<body>
  <div class="editor-container">
    <div class="editor">
      <h3>Language</h3>
      <input type="file" id="loadLanguageFile" accept=".xml">
      <br>
      <textarea id="languageText" cols="80"
        placeholder="Paste language.xml here"></textarea>
      <br>
      <button id="loadLanguageText">Load language from text</button>

    </div>
    <div class="editor">

      <h3>Model</h3>
      <input type="file" id="loadModelFile" accept=".xml" disabled >
      <br>
      <textarea id="modelText" cols="80" disabled
        placeholder="Paste model.xml here"></textarea>
      <br>
      <button id="loadModelText" disabled >Load model from text</button>
    </div>
  </div> 
  <hr>
  <div id="log"></div>

  <script>
  /* ===========================
     GLOBALS
     =========================== */
  let languageEnv = null;
  const ui = {
    loadLanguageFile: document.getElementById("loadLanguageFile"),
    loadLanguageText: document.getElementById("loadLanguageText"),
    languageText: document.getElementById("languageText"),
    loadModelFile: document.getElementById("loadModelFile"),
    loadModelText: document.getElementById("loadModelText"),
    modelText: document.getElementById("modelText"),
    log: document.getElementById("log"),
  };

  /* ===========================
     INITIALIZATION
     =========================== */
  ui.loadLanguageFile
    .addEventListener("change", onLoadLanguageChange);

  ui.loadLanguageText
    .addEventListener("click", onLoadLanguageText);

  ui.loadModelFile
    .addEventListener("change", onLoadModelChange);

  ui.loadModelText
    .addEventListener("click", onLoadModelText);

  /* ===========================
     FUNCTIONS
     =========================== */

  function onLoadLanguageChange(e){
    const file = e.target.files[0];
    if (!file) return;
    setValidLanguage(file);
  };

  function onLoadLanguageText() {
    const text = ui.languageText.value.trim();
    if (!text) return;
    try {
      const xml = parseXmlOrThrow(text, "pasted language.xml");
      const lang = parseAndValidateLanguage(xml, "pasted language.xml");
      commitLanguage(lang);
    } catch (er) {
      rejectLanguage(er);
    }
  }

  function onLoadModelChange(e){
    if (!languageEnv) {
      rejectModelInput("✖ Load language.xml first.\n");
      return;
    }
    const file = e.target.files[0];
    if (!file) return;
    parseAndValidateLoadedModel(file);
  };

  function onLoadModelText() {
    if (!languageEnv) {
      rejectModelInput("✖ Load language.xml first.\n");
      return;
    }
    const text = ui.modelText.value.trim();
    if (!text) return;

    try {
      validateModelText(text, "pasted model.xml");
    } catch (er) {
      setLogText(formatModelError(er));
    }
  }

  function setValidLanguage(file){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        ui.languageText.value = reader.result;          // assuming common next action is to tweak it
        const xml = parseXmlOrThrow(reader.result, file.name);
        const lang = parseAndValidateLanguage(xml, file.name);
        commitLanguage(lang);
      } catch (er) {
        rejectLanguage(er);
      }
    };
    reader.readAsText(file);
  }

  function enableControls(isLanguageLoaded){
    enableInput(ui.loadModelFile, isLanguageLoaded);
    enableInput(ui.modelText, isLanguageLoaded);
    enableInput(ui.loadModelText, isLanguageLoaded);
  }

  function rejectModelInput(message) {
    ui.loadModelFile.value = null;
    ui.modelText.value = "";
    setLogText(message);
  }

  function validateModelText(xmlText, filename) {
    const result = validateModel(xmlText, filename, languageEnv);
    setLogText(formatModelResult(result));
  }

  function commitLanguage(lang) {
    languageEnv = lang;
    setLogText(formatLanguageLoaded(lang));
    enableControls(true);
    resetModelInputs();
  }

  function resetModelInputs() {
    ui.loadModelFile.value = null;
    ui.modelText.value = "";
  }

  function rejectLanguage(er) {
    languageEnv = null;
    setLogText(formatModelError(er));
    enableControls(false);
    resetModelInputs();
  }

  function parseAndValidateLoadedModel(file){
    const reader = new FileReader();
    reader.onload = () => {
      try {
        ui.modelText.value = reader.result;          // assuming common next action is to tweak it
        validateModelText(reader.result, file.name);
      } catch (er) {
        setLogText(formatModelError(er));
      }
    };
    reader.readAsText(file);
  }

  function validateModel(xmlText, filename, language) {
    const xml = parseXmlOrThrow(xmlText, filename);
    const obj = getObjectFromXML(xml);
    const features = getModelFeatures(obj, language);
    return { features, obj, filename };
  }

  function formatModelResult({ features, obj, filename }) {
    const {
      indexSets,
      variables,
      resolvedVars,
      dependencies
    } = features;

    return [
      "✔ Model is structurally valid",
      "",
      "Index sets:",
      indexSets.join(", ") || "(none)",
      "",
      "Variables:",
      variables.join(", ") || "(none)",
      "",
      "Resolved variables:",
      getObjectAsString(mapToObject(resolvedVars)),
      "",
      "Dependencies:",
      getObjectAsString(mapOfSetsToObject(dependencies)),
      "",
      `${filename} as object:`,
      getObjectAsString(obj)
    ].join("\n");
  }

  function formatModelError(err) {
    const lines = [
      "✖ Validation error:",
      err.message
    ];
    if (err.context) {
      lines.push(
        "",
        "Context:",
        getObjectAsString(err.context)
      );
    }
    return lines.join("\n");
  }

  function parseAndValidateLanguage(xmlDoc, filename) {
    const functions = new Map();
    const fnNodes = xmlDoc.querySelectorAll("functions > function");
    for (const fn of fnNodes) {
      const name = fn.getAttribute("name");
      const arity = Number(fn.getAttribute("arity"));
      const serializer = new XMLSerializer();
      const fnXml = serializer.serializeToString(fn);
      if (!name ) {
        throw new Error("Invalid function declaration in " + filename + ": function without name \n" + fnXml);
      }
      if (Number.isNaN(arity)) {
        throw new Error("Invalid function declaration in " + filename + ": function with non-numeric arity \n" + fnXml);
      }
      functions.set(name, { arity });
    }
    return { functions };
  }

  function formatLanguageLoaded(lang) {
    return "Language loaded:\n " + getObjectAsString(
      { functions: Object.fromEntries(lang.functions) }
    );
  }

  /* ===========================
     XML → JS object
     =========================== */
  function getObjectFromXML(xml) {
    function getObjectFromNode(node) {
      const obj = {};
      // attributes
      if (node.attributes) {
        for (const attr of node.attributes) {
          obj[attr.name] = attr.value;
        }
      }
      // child nodes
      for (const child of node.childNodes) {
        if (child.nodeType === Node.ELEMENT_NODE) { // === 1
          const name = child.nodeName;
          const value = getObjectFromNode(child);
          if (obj[name]) {  // obj[name] already exists so Make it an array and add elements to the array
            if (!Array.isArray(obj[name])) {
              obj[name] = [obj[name]];
            }
            obj[name].push(value);
          } else {  // obj[name] doesn't exist so create it and set its value
            obj[name] = value;
          }
        }
        if (child.nodeType === Node.TEXT_NODE ) { // === 3
          const text = child.nodeValue.trim();
          if (text) {
            obj["#text"] = text;  // so if there is more than one bit of text it just takes the last one
          }
        }
      }
      return obj;
    }
    return { model: getObjectFromNode(xml.documentElement) };
  }

  function getModelFeatures(xmlModel, lang) {
    const symbols = collectSymbols(xmlModel);
    const resolvedVars = resolveDomains(symbols);
    const dependencies = resolveReferences(symbols, resolvedVars, lang);
    detectCycles(dependencies);
    return {
      indexSets: [...symbols.indexSets.keys()],   // an array containing all the keys from the indexSets map
      variables: [...symbols.variables.keys()],    // an array containing all the keys from the variables map
      resolvedVars,
      dependencies   
    };
  }


  /* ===========================
     Validate Step 1: Collect symbols
     =========================== */
  function collectSymbols(xml) {
    const indexSets = new Map();
    const units = new Map();
    const tables = new Map();
    const variables = new Map();

    for (const is of asArray(xml.model.indexSets?.indexSet)) {
      if (indexSets.has(is.id)) {
        throwModelError("Duplicate index set", { id: is.id });
      }
      indexSets.set(is.id, is);
    }

    for (const u of asArray(xml.model.units?.unit)) {
      units.set(u.id, u);
    }

    for (const t of asArray(xml.model.tables?.table)) {
      tables.set(t.id, t);
    }

    for (const v of asArray(xml.model.variables?.variable)) {
      if (variables.has(v.id)) {
        throwModelError("Duplicate variable", { id: v.id });
      }
      variables.set(v.id, v);
    }

    return { indexSets, units, tables, variables };
  }

  /* ===========================
     Validate Step 2: Resolve domains
     =========================== */
  function resolveDomains(symbols) {
    const resolved = new Map();

    for (const [name, v] of symbols.variables) {
      const args = [];

      for (const arg of asArray(v.arguments?.arg)) {
        const indexSet = symbols.indexSets.get(arg.indexSet);
        if (!indexSet) {
          throwModelError("Unknown index set", {
            variable: name,
            indexSet: arg.indexSet
          });
        }
        args.push(indexSet.id);
      }

      resolved.set(name, {
        name,
        domain: args,
        xml: v
      });
    }

    return resolved;
  }

  /* ===========================
     Validate Step 3: Resolve references
     =========================== */
  function resolveReferences(symbols, resolvedVars, lang) {
    const dependencies = new Map();

    for (const [name, resolvedVariable] of resolvedVars) {
      dependencies.set(name, new Set());
      const def = resolvedVariable.xml.definition;
      if (!def) continue;

      if (def.type === "expression") {
        const refs = extractStringsFollowedByBrackets(def["#text"] || "");
        for (const r of refs) {
          if (symbols.variables.has(r)) {
            dependencies.get(name).add(r);
            continue;
          }

          if (lang.functions.has(r)) {
            continue; // built-in function
          }

          throwModelError("Unknown identifier", {
            variable: name,
            reference: r
          });
        }
      }

      if (def.type === "table") {
        const tableId = def.table?.ref;
        if (!symbols.tables.has(tableId)) {
          throwModelError("Unknown table", {
            variable: name,
            table: tableId
          });
        }
      }
    }

    return dependencies;
  }

  function extractStringsFollowedByBrackets(exprText) {
    const regex = /([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;   // all matches of strings followed by left round bracket 
    const refs = new Set();
    let m;
    while ((m = regex.exec(exprText)) !== null) {
      refs.add(m[1]);
    }
    return [...refs];
  }


  /* ===========================
     Validate Step 4: Cycle detection
     =========================== */
  function detectCycles(dependencies) {
    const visited = new Set();
    const stack = new Set();

    function visit(v) {
      if (stack.has(v)) return [v];
      if (visited.has(v)) return null;

      visited.add(v);
      stack.add(v);

      for (const d of dependencies.get(v) || []) {
        const cycle = visit(d);
        if (cycle) {
          cycle.push(v);
          return cycle;
        }
      }

      stack.delete(v);
      return null;
    }

    for (const v of dependencies.keys()) {
      const cycle = visit(v);
      if (cycle) {
        throwModelError("Dependency cycle detected", { cycle });
      }
    }
  }

  /* ===========================
     Helpers
     =========================== */
  function asArray(x){
    return [].concat(x || []);
  }
  
  function enableInput(el, qualifier){
    el.disabled = !qualifier;
  };

  function getObjectAsString(obj) {
    return  JSON.stringify(obj || {}, null, 2);
  }

  function mapToObject(map) {
    return Object.fromEntries(map);
  }

  function mapOfSetsToObject(map) {
    return Object.fromEntries(
      [...map.entries()].map(([k, v]) => [k, [...v]])
    );
  }

  function nullifyInputWithMessage(input, message) {
    input.value = '';
    setLogText(message);
  }

  function parseXmlOrThrow(text, label) {
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const err = xml.getElementsByTagName("parsererror")[0];
    if (err) {
      throw new Error(`Invalid XML in ${label}`);
    }
    return xml;
  }

  function setLogText(s){
      const log = ui.log;
      log.textContent = s;
  }

  function throwModelError(message, context = {}) {
    const err = new Error(message);
    err.context = context;
    throw err;
  }



  </script>

</body>
</html>
