<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">  
  <title>Model XML Validator</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
    }
    #log {
      margin-top: 1rem;
      white-space: pre-wrap;
      font-family: monospace;
      border: 1px solid #ccc;
      padding: 1rem;
    }
    .editor-container {
      display: flex;
      gap: 24px;
      align-items: flex-start;
    }
    
    .editor {
      display: flex;
      flex-direction: column;
    }

    .editor textarea {
      flex: 1;              /* fills available space */
      min-height: 130px;    /* pick a height you like */
      resize: vertical;    /* optional: allow user resize */
    }

    /* ======================================================
       Mobile layout
       ====================================================== */
    @media (max-width: 768px) {

      body {
        padding: 1rem;
      }

      .editor-container {
        flex-direction: column;   /* stack */
        gap: 16px;
      }

      .editor textarea {
        width: 100%;              /* ignore cols="80" */
        min-height: 180px;
        font-size: 16px;          /* stops iOS zoom */
      }

      input[type="file"],
      button {
        font-size: 16px;          /* easier tapping */
      }

      #log {
        font-size: 14px;
        overflow-x: auto;
      }
    }

  </style>
</head>
<body>
  <div class="editor-container">
    <div class="editor">
      <h3>Language</h3>
      <input type="file" id="loadLanguageFile" accept=".xml">
      <br>
      <textarea id="languageText" cols="80"
        placeholder="Paste language.xml here"></textarea>
      <br>
      <button id="loadLanguageText">Load language from text</button>

    </div>
    <div class="editor">

      <h3>Model</h3>
      <input type="file" id="loadModelFile" accept=".xml" disabled >
      <br>
      <textarea id="modelText" cols="80" disabled
        placeholder="Paste model.xml here"></textarea>
      <br>
      <button id="loadModelText" disabled >Load model from text</button>
    </div>
  </div> 
  <hr>
  <div id="log"></div>

  <script>
  /* ===========================
     GLOBALS
     =========================== */
  let languageEnv = null;
  const ui = {
    loadLanguageFile: document.getElementById("loadLanguageFile"),
    loadLanguageText: document.getElementById("loadLanguageText"),
    languageText: document.getElementById("languageText"),
    loadModelFile: document.getElementById("loadModelFile"),
    loadModelText: document.getElementById("loadModelText"),
    modelText: document.getElementById("modelText"),
    log: document.getElementById("log"),
  };

  /* ======================================================
     1. HANDLERS   ui → applications 
     ====================================================== */
  ui.loadLanguageFile
    .addEventListener("change", onLoadLanguageChange);

  ui.loadLanguageText
    .addEventListener("click", onLoadLanguageText);

  ui.loadModelFile
    .addEventListener("change", onLoadModelChange);

  ui.loadModelText
    .addEventListener("click", onLoadModelText);

  /* ===========================
     2. APPLICATIONS prepare → call domain → interpret → update state/UI 
     =========================== */

  // Entry point from "Load language" file input.
  // Reads text from file, then sends it for loading or rejection.
  function onLoadLanguageChange(e){
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      ui.languageText.value = reader.result;          // assuming common next action is to tweak it
      commitOrRejectLanguage(reader.result, file.name) 
    };
    reader.readAsText(file);
  };

  // Entry point from "Load language from text" button.
  // Reads text from textarea, then sends it for loading or rejection.
  function onLoadLanguageText() {
    const text = ui.languageText.value.trim();
    commitOrRejectLanguage(text, "language in textarea"); 
  }

  // Orchestrates language load success vs failure.
  function commitOrRejectLanguage(text, sourceLabel) {
    if (!text) return;
    try {
      const xml = parseXmlOrThrow(text,  sourceLabel);
      const lang = getFunctionsFromLanguage(xml,  sourceLabel);
      commitLanguage(lang);
    } catch (er) {
      rejectLanguage(er);
    }
  }

  // Entry point from "Load model" file input.
  // Validates prerequisites, reads model from file, copies it to textarea, sends it on for reporting.
  function onLoadModelChange(e){
    if (!languageEnvIsSet()) return;
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      ui.modelText.value = reader.result;   // copies model to textarea assuming typical next user step will be to tweak model manually
      validateModel(reader.result, file.name, languageEnv)
    };
    reader.readAsText(file);
  };

  // Entry point from "Load model from text" button.
  // Validates prerequisites, reads model from textarea, sends it on for reporting.
  function onLoadModelText() {
    if (!languageEnvIsSet()) return;
    const text = ui.modelText.value.trim();
    if (!text) return;
    validateModel(text, "model in textarea", languageEnv)
  }

  // Gets report on model and pastes it to log or reports any error.
  function validateModel(text, filename, lang){
    try {
    const xml = parseXmlOrThrow(text, filename);
    const obj = getObjectFromXML(xml);
    const features = getModelFeatures(obj, lang);
    const report = { features, obj, filename };
    setLogText(formatModelResult(report));
    } catch (er) {
      setLogText(formatError(er));
    }
  }

  // passes xmlModel and lang to parsers to get an object containing parsed model features (variables, dependencie i.e. immediate precedents) 
  function getModelFeatures(xmlModel, lang) {
    const symbols = getMapsOfModelFeatures(xmlModel);
    const resolvedVars = getConfirmationThatVariableArgumentsAreIndexSets(symbols);
    const dependencies = getDependencies(symbols, resolvedVars, lang);
    detectCircularExpressions(dependencies);
    return {
      indexSets: [...symbols.indexSets.keys()],   // an array containing all the keys from the indexSets map
      variables: [...symbols.variables.keys()],    // an array containing all the keys from the variables map
      resolvedVars,
      dependencies   
    };
  }

  
  // Returns true (with no side-effects) if language is set, otherwise sends an instruction to update UI and state and returns false.
  function languageEnvIsSet(){
    if (!languageEnv) {
      rejectModelInput("✖ Load language.xml first.\n");
      return false;
    }
    return true;
  }

  // Updates UI (controls) depending on whether language has been loaded.
  function enableControls(isLanguageLoaded){
    enableElement(ui.loadModelFile, isLanguageLoaded);
    enableElement(ui.modelText, isLanguageLoaded);
    enableElement(ui.loadModelText, isLanguageLoaded);
  }

  // Updates UI (resets model input controls) and sets log to message
  function rejectModelInput(message) {
    ui.loadModelFile.value = null;
    ui.modelText.value = "";
    setLogText(message);
  }

  // Updates state (languageEnv) and UI (log and controls) for a new language lang
  function commitLanguage(lang) {
    languageEnv = lang;
    setLogText(formatLanguageLoaded(lang));
    enableControls(true);
    resetModelInputs();
  }

  // Updates  UI (clears model file and textarea inputs)
  function resetModelInputs() {
    ui.loadModelFile.value = null;
    ui.modelText.value = "";
  }

  // Updates state (languageEnv) and UI (controls, and log with info about error er)
  function rejectLanguage(er) {
    languageEnv = null;
    setLogText(formatError(er));
    enableControls(false);
    resetModelInputs();
  }


  /* ===========================
     3. DOMAIN - return knowledge / analysis about arguments provided, with no unecessary side-effects 
     =========================== */

  // determines if xmlDoc is an valid language and returns its functions or throws an error if it is an invalid language
  // throws error if domain rules are broken (functions without a name or with non-numeric arity)
  function getFunctionsFromLanguage(xmlDoc, filename) {
    const functions = new Map();
    const fnNodes = xmlDoc.querySelectorAll("functions > function");
    for (const fn of fnNodes) {
      const name = fn.getAttribute("name");
      const arity = Number(fn.getAttribute("arity"));
      const serializer = new XMLSerializer();
      const fnXml = serializer.serializeToString(fn);
      if (!name ) {
        throw new Error("Invalid function declaration in " + filename + ": function without name \n" + fnXml);
      }
      if (Number.isNaN(arity)) {
        throw new Error("Invalid function declaration in " + filename + ": function with non-numeric arity \n" + fnXml);
      }
      functions.set(name, { arity });
    }
    return { functions };
  }

  // returns in one object maps of indexSets, units, tables, variables in xml
  // throws error if domain rules are broken (duplicate index sets, duplicate variables)
  function getMapsOfModelFeatures(xml) {
    const indexSets = new Map();
    const units = new Map();
    const tables = new Map();
    const variables = new Map();
    for (const indSet of asArray(xml.model.indexSets?.indexSet)) {
      if (indexSets.has(indSet.id)) {
        throwModelError("Duplicate index set", { id: indSet.id });
      }
      indexSets.set(indSet.id, indSet);
    }
    for (const u of asArray(xml.model.units?.unit)) {
      units.set(u.id, u);
    }
    for (const t of asArray(xml.model.tables?.table)) {
      tables.set(t.id, t);
    }
    for (const v of asArray(xml.model.variables?.variable)) {
      if (variables.has(v.id)) {
        throwModelError("Duplicate variable", { id: v.id });
      }
      variables.set(v.id, v);
    }
    return { indexSets, units, tables, variables };
  }

  // returns map of variables whose arguments are verified to be IndexSets
  // throws error if domain rules are broken (arguments not recognised as IndexSets)
  function getConfirmationThatVariableArgumentsAreIndexSets(symbols) {
    const resolved = new Map();
    for (const [name, v] of symbols.variables) {
      const args = [];
      for (const arg of asArray(v.arguments?.arg)) {
        const indexSet = symbols.indexSets.get(arg.indexSet);
        if (!indexSet) {
          throwModelError("Unknown index set", {
            variable: name,
            indexSet: arg.indexSet
          });
        }
        args.push(indexSet.id);
      }
      resolved.set(name, {
        name,
        domain: args,
        xml: v
      });
    }
    return resolved;
  }

  // gets a map of dependencies
  // throws error if there is an undefined reference: string in formula not a variable nor a function, or undefined table)
function getDependencies(symbols, resolvedVars, lang) {
  const dependencies = new Map();

  for (const [name, resolvedVariable] of resolvedVars) {
    const deps = new Set();
    dependencies.set(name, deps);

    const def = resolvedVariable.xml.definition;
    if (!def) continue;

    // ------------------------
    // 1. expression
    // ------------------------
    if (def.type === "expression") {
      getExpressionRefs(def["#text"], symbols, lang, name, deps);
    }

    // ------------------------
    // 2. piecewise
    // ------------------------
    if (def.type === "piecewise") {
      for (const c of asArray(def.case)) {
        getExpressionRefs(c.when?.["#text"], symbols, lang, name, deps);
        getExpressionRefs(c.value?.["#text"], symbols, lang, name, deps);
      }
    }

    // ------------------------
    // 3. table
    // ------------------------
    if (def.type === "table") {
      const tableId = def.table?.ref;
      if (!symbols.tables.has(tableId)) {
        throwModelError("Unknown table", {
          variable: name,
          table: tableId
        });
      }
    }

    // ------------------------
    // 4. tableLookup  ⭐ NEW
    // ------------------------
    if (def.type === "tableLookup") {
      const tableId = def.table?.ref;
      if (!symbols.tables.has(tableId)) {
        throwModelError("Unknown table", {
          variable: name,
          table: tableId
        });
      }

      getTableLookupRefs(def, symbols, name, deps);
    }
  }

  return dependencies;
}

  // throw an error if e.g. a depends on B which depends on C which depends on A.
function detectCircularExpressions(dependencies) {
  const visited = new Set();
  const stack = [];

  function visit(v) {
    if (stack.includes(v)) {
      // extract cycle
      const start = stack.indexOf(v);
      return stack.slice(start);
    }
    if (visited.has(v)) return null;

    visited.add(v);
    stack.push(v);

    for (const edge of dependencies.get(v) || []) {
      const cycle = visit(edge.name);
      if (cycle) {
        cycle.push(v);
        return cycle;
      }
    }

    stack.pop();
    return null;
  }

  for (const v of dependencies.keys()) {
    const cycle = visit(v);
    if (cycle) {
      // check shifts
      const hasLag = cycle.some((name, i) => {
        const from = cycle[i];
        const to = cycle[(i + 1) % cycle.length];
        return [...dependencies.get(from)].some(
          e => e.name === to && e.shift < 0
        );
      });

      if (!hasLag) {
        throwModelError("Circular expressions detected", { cycle });
      }
    }
  }
}
     
  // gets functions and variables which are strings followed by left round bracket e.g. the "if" in "if(...)"
  function extractStringsFollowedByBrackets(exprText) {
    const regex = /([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;   // all matches of strings followed by left round bracket 
    const refs = new Set();
    let m;
    while ((m = regex.exec(exprText)) !== null) {
      refs.add(m[1]);
    }
    return [...refs];
  }


function getExpressionRefs(text, symbols, lang, ownerName, deps) {
  const refs = extractStringsFollowedByBrackets(text || "");
  for (const r of refs) {
    if (symbols.variables.has(r)) {
      deps.add(r);
      continue;
    }
    if (lang.functions.has(r)) continue;

    throwModelError("Unknown identifier", {
      variable: ownerName,
      reference: r
    });
  }
}

function getTableLookupRefs(def, symbols, ownerName, deps) {
  const row = def.row?.ref;
  if (row) {
    if (!symbols.variables.has(row)) {
      throwModelError("Unknown identifier", {
        variable: ownerName,
        reference: row
      });
    }
    deps.add(row);
  }

  const colSel = def.columnSelector?.ref;
  if (colSel) {
    if (!symbols.variables.has(colSel)) {
      throwModelError("Unknown identifier", {
        variable: ownerName,
        reference: colSel
      });
    }
    deps.add(colSel);
  }
}


  /* ===========================
     4. FORMAT - make data structures readable by human users
     =========================== */
  function formatModelResult({ features, obj, filename }) {
    const {
      indexSets,
      variables,
      resolvedVars,
      dependencies
    } = features;

    return [
      "✔ Model is structurally valid",
      "",
      "Index sets:",
      indexSets.join(", ") || "(none)",
      "",
      "Variables:",
      variables.join(", ") || "(none)",
      "",
      "Resolved variables:",
      getStringfromObject(getObjectFromMap(resolvedVars)),
      "",
      "Dependencies:",
      getStringfromObject(getObjectFromMapOfSets(dependencies)),
      "",
      `${filename} as object:`,
      getStringfromObject(obj)
    ].join("\n");
  }

  function formatError(err) {
    const lines = [
      "✖ Validation error:",
      err.message
    ];
    if (err.context) {
      lines.push(
        "",
        "Context:",
        getStringfromObject(err.context)
      );
    }
    return lines.join("\n");
  }


  function formatLanguageLoaded(lang) {
    return "Language loaded:\n " + getStringfromObject(
      { functions: Object.fromEntries(lang.functions) }
    );
  }






  /* ===========================
     Validate Step 4: Cycle detection
     =========================== */

  /* ===========================
     HELPERS - helps code run
     =========================== */
  function asArray(x) {
    if (x == null) return [];     // null or undefined
    return Array.isArray(x) ? x : [x];
  }
  
  function enableElement(el, qualifier){
    el.disabled = !qualifier;
  };

  function getStringfromObject(obj) {
    return  JSON.stringify(obj || {}, null, 2);
  }

  function getObjectFromMap(map) {
    return Object.fromEntries(map);
  }

  function getObjectFromMapOfSets(map) {
    return Object.fromEntries(
      [...map.entries()].map(([k, v]) => [k, [...v]])
    );
  }


  function parseXmlOrThrow(text, label) {
    const xml = new DOMParser().parseFromString(text, "application/xml");
    const err = xml.getElementsByTagName("parsererror")[0];
    if (err) {
      throw new Error(`Invalid XML in ${label}`);
    }
    return xml;
  }

  function setLogText(s){
      const log = ui.log;
      log.textContent = s;
  }

  function throwModelError(message, context = {}) {
    const err = new Error(message);
    err.context = context;
    throw err;
  }

  /* ===========================
     XML → JS object
     =========================== */
  function getObjectFromXML(xml) {
    function getObjectFromNode(node) {
      const obj = {};
      // attributes
      if (node.attributes) {
        for (const attr of node.attributes) {
          obj[attr.name] = attr.value;
        }
      }
      // child nodes
      for (const child of node.childNodes) {
        if (child.nodeType === Node.ELEMENT_NODE) { // === 1
          const name = child.nodeName;
          const value = getObjectFromNode(child);
          if (obj[name]) {  // obj[name] already exists so Make it an array and add elements to the array
            if (!Array.isArray(obj[name])) {
              obj[name] = [obj[name]];
            }
            obj[name].push(value);
          } else {  // obj[name] doesn't exist so create it and set its value
            obj[name] = value;
          }
        }
        if (child.nodeType === Node.TEXT_NODE ) { // === 3
          const text = child.nodeValue.trim();
          if (text) {
            obj["#text"] = text;  // so if there is more than one bit of text it just takes the last one
          }
        }
      }
      return obj;
    }
    return { model: getObjectFromNode(xml.documentElement) };
  }


  </script>

</body>
</html>
